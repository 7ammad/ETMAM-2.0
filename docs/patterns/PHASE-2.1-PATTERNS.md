# Phase 2.1 — AI Provider Setup: Patterns & Gotchas

> Generated by Claude Code skill stack (google-gemini-api, prompt-engineering-patterns, error-handling-patterns, typescript-advanced-types).
> Read this alongside IMPLEMENTATION.md Phase 2.1, BACKEND.md, and TECH-STACK.md.

---

## CRITICAL CONTEXT: Most AI Infra Is Already Scaffolded

**READ THIS FIRST.** Unlike previous phases, Phase 2.1 has 6 files already implemented in `src/lib/ai/`:

| File | Status | What's There |
|------|--------|-------------|
| `provider.ts` | **REAL** — Full `AIProvider` interface, `getAIProvider()` factory, MOCK_AI support | Do NOT rewrite |
| `gemini.ts` | **REAL** — `GeminiProvider` class with `analyze()` + `extractFromPDF()`, `responseMimeType: "application/json"` | Needs retry/timeout |
| `groq.ts` | **REAL** — `GroqProvider` class with `analyze()`, throws on PDF extraction | Needs retry/timeout |
| `mock-provider.ts` | **REAL** — `MockProvider` with realistic mock data for both methods | Do NOT touch |
| `prompts.ts` | **REAL** — `TENDER_ANALYSIS_PROMPT`, `SECTION_TARGETED_EXTRACTION_PROMPT`, `buildAnalysisPrompt()` | Do NOT rewrite |
| `parser.ts` | **REAL** — Zod schemas, `extractJSON()`, type exports | Verify `zod/v4` import |

**Phase 2.1 scope = wire + harden + test, NOT rewrite.**

---

## GOTCHAS (Read First)

### G1: Do NOT Rewrite Existing AI Files — Add to Them

**CRITICAL**: The 6 files in `src/lib/ai/` are real implementations, not stubs. They were scaffolded in Phase 1.1 with full logic. Phase 2.1 is about:

1. Adding retry + timeout logic (missing)
2. Adding extraction caching (missing)
3. Verifying the mock provider matches Zod schemas
4. Verifying Gemini/Groq calls work end-to-end
5. Fixing any type mismatches

```typescript
// ❌ WRONG — Rewriting from scratch
export class GeminiProvider implements AIProvider {
  // ... entire new implementation
}

// ✅ CORRECT — Add retry/timeout to existing implementation
// Keep the existing gemini.ts structure, wrap API calls with retry helper
```

---

### G2: `recommendation` Field Name Mismatch — `"pursue"` vs `"proceed"`

**CRITICAL**: There are two different recommendation value sets:

| Location | Values | Used By |
|----------|--------|---------|
| `AIAnalysisResult` in `provider.ts` | `"pursue" \| "review" \| "skip"` | AI prompts, parser |
| `Tender.recommendation` in `database.ts` | `"proceed" \| "review" \| "skip"` | DB, evaluations table |
| `analysisResponseSchema` in `parser.ts` | `"pursue" \| "review" \| "skip"` | Zod validation |

**Solution**: Map `"pursue"` → `"proceed"` when saving to the `evaluations` table in Phase 2.2. Phase 2.1 can keep the AI's `"pursue"` as-is — the mapping happens in the `analyzeTender` Server Action (Phase 2.2).

Do NOT change the prompt or the parser schema — they're correct for the AI's output format. The DB mapping is Phase 2.2's job.

---

### G3: `parser.ts` Imports `zod/v4` — Verify This Works

The parser imports from `"zod/v4"`:

```typescript
// parser.ts:5
import { z } from "zod/v4";
```

Check your installed zod version. If using `zod@3.x`, this import path doesn't exist — it should be `"zod"`. If using `zod@4.x-beta`, `"zod/v4"` is correct.

```bash
# Check installed version
pnpm ls zod
```

```typescript
// If zod@3.x → change to:
import { z } from "zod";

// If zod@4.x → keep as-is:
import { z } from "zod/v4";
```

**This is a potential build-breaker.** Verify immediately.

---

### G4: No Retry or Timeout Logic Exists — Must Add

Neither `gemini.ts` nor `groq.ts` have retry or timeout logic. IMPLEMENTATION.md requires: "errors, retries (1 retry), timeouts (30s)".

```typescript
// ❌ CURRENT — No retry, no timeout
const result = await model.generateContent(prompt);

// ✅ CORRECT — Wrap with retry + timeout
const result = await withRetry(
  () => withTimeout(model.generateContent(prompt), 30_000),
  { maxRetries: 1, backoffMs: 2000 }
);
```

See Pattern 1 below for the full implementation.

---

### G5: MOCK_AI Fallback Chain Already Works — Don't Break It

The `getAIProvider()` in `provider.ts` has a smart fallback:

```
MOCK_AI=true → MockProvider
AI_PROVIDER=groq + GROQ_API_KEY → GroqProvider
GEMINI_API_KEY → GeminiProvider
GROQ_API_KEY → GroqProvider (fallback)
No keys at all → MockProvider (graceful)
```

This is correct. Do NOT change this logic. The mock fallback ensures local dev works without keys.

---

### G6: No Extraction Cache Wired — But Table Exists

BACKEND.md defines an `extraction_cache` table (keyed by file SHA-256 hash), and the `ExtractionResult` type has a `cached: boolean` field. But `gemini.ts` does NOT check the cache before calling the API.

For Phase 2.1 scope: **skip extraction caching** — it's an optimization for PDF extraction (Phase 2.2). Phase 2.1 focuses on the `analyze()` method, which doesn't use caching.

If you do add it, the pattern is:

```typescript
// In extractFromPDF — OPTIONAL for Phase 2.1
import crypto from "crypto";

const hash = crypto.createHash("sha256").update(fileBuffer).digest("hex");
const { data: cached } = await supabase
  .from("extraction_cache")
  .select("extraction_result")
  .eq("file_hash", hash)
  .single();

if (cached) {
  return { ...cached.extraction_result, cached: true };
}
```

---

### G7: `buildAnalysisPrompt` Weight Keys Must Match Settings Store

The `buildAnalysisPrompt()` function in `prompts.ts` expects a weights object with specific keys:

```typescript
// prompts.ts:87-91
.replace("{relevanceWeight}", String(weights.relevance ?? 30))
.replace("{budgetWeight}", String(weights.budgetFit ?? 25))
.replace("{timelineWeight}", String(weights.timeline ?? 20))
.replace("{competitionWeight}", String(weights.competition ?? 15))
.replace("{strategicWeight}", String(weights.strategic ?? 10))
```

The settings store (`settings-store.ts`) uses the same keys:

```typescript
scoringWeights: {
  relevance: 30,
  budgetFit: 25,
  timeline: 20,
  competition: 15,
  strategic: 10,
}
```

These match. When calling `analyze()` in Phase 2.2's Server Action, pass `useSettingsStore.getState().scoringWeights` directly. But since stores are client-only (Zustand), the Server Action will need to receive weights as a parameter from the client.

---

### G8: `analysis-store.ts` References `TenderAnalysis` from `types/ai.ts`

The analysis store already exists with queue management (`addToQueue`, `setProcessing`, `removeFromQueue`). The `TenderAnalysis` type in `types/ai.ts` matches the `AIAnalysisResult` from `provider.ts` with additional fields (`id`, `tender_id`, `model_used`, `status`, `created_at`, `updated_at`).

When saving analysis results, you'll need to merge `AIAnalysisResult` into a `TenderAnalysis` by adding the metadata fields.

---

### G9: Gemini Model Name — Use What's in the Code

`gemini.ts` uses `"gemini-2.5-flash"`. TECH-STACK.md mentions `"gemini-2.5-flash-preview-05-20"`. The code's value is what actually runs. Don't change it unless the API rejects it. The settings store also stores `geminiModel: "gemini-2.5-flash"`.

---

## Pattern 1: Retry + Timeout Utility

Create a shared utility that both providers can use:

```typescript
// lib/ai/retry.ts
export class AIError extends Error {
  constructor(
    message: string,
    public readonly code: "TIMEOUT" | "RATE_LIMITED" | "INVALID_RESPONSE" | "API_ERROR" | "AUTH_ERROR",
    public readonly retryable: boolean,
    public readonly cause?: unknown
  ) {
    super(message);
    this.name = "AIError";
  }
}

/**
 * Wrap a promise with a timeout.
 * Rejects with AIError("TIMEOUT") if the promise doesn't resolve in time.
 */
export function withTimeout<T>(
  promise: Promise<T>,
  timeoutMs: number
): Promise<T> {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => {
      reject(new AIError(
        `AI request timed out after ${timeoutMs}ms`,
        "TIMEOUT",
        true
      ));
    }, timeoutMs);

    promise
      .then((result) => {
        clearTimeout(timer);
        resolve(result);
      })
      .catch((err) => {
        clearTimeout(timer);
        reject(err);
      });
  });
}

/**
 * Retry a function with exponential backoff.
 * Only retries on retryable errors.
 */
export async function withRetry<T>(
  fn: () => Promise<T>,
  options: { maxRetries?: number; baseDelayMs?: number } = {}
): Promise<T> {
  const { maxRetries = 1, baseDelayMs = 2000 } = options;
  let lastError: unknown;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (err) {
      lastError = err;

      // Don't retry non-retryable errors
      if (err instanceof AIError && !err.retryable) {
        throw err;
      }

      // Don't retry if we've exhausted attempts
      if (attempt >= maxRetries) {
        break;
      }

      // Exponential backoff
      const delay = baseDelayMs * Math.pow(2, attempt);
      await new Promise((r) => setTimeout(r, delay));
    }
  }

  throw lastError;
}

/**
 * Classify API errors into typed AIError.
 * Use in catch blocks of provider methods.
 */
export function classifyError(err: unknown): AIError {
  if (err instanceof AIError) return err;

  const message = err instanceof Error ? err.message : String(err);

  // Gemini / Groq rate limit
  if (message.includes("429") || message.includes("rate") || message.includes("quota")) {
    return new AIError("تم تجاوز حد الاستخدام، حاول لاحقاً", "RATE_LIMITED", true, err);
  }

  // Auth errors
  if (message.includes("401") || message.includes("403") || message.includes("API key")) {
    return new AIError("مفتاح API غير صالح", "AUTH_ERROR", false, err);
  }

  // Parse errors
  if (message.includes("JSON") || message.includes("parse") || message.includes("Zod")) {
    return new AIError("فشل تحليل استجابة AI", "INVALID_RESPONSE", true, err);
  }

  // Default
  return new AIError("حدث خطأ أثناء تحليل AI: " + message, "API_ERROR", true, err);
}
```

---

## Pattern 2: Applying Retry to GeminiProvider

Modify the existing `gemini.ts` to use the retry utility. **Don't rewrite — wrap the API calls.**

```typescript
// In gemini.ts — add imports at top
import { withRetry, withTimeout, classifyError, AIError } from "./retry";

// In analyze() method — wrap the generateContent call
async analyze(
  tenderContent: string,
  weights: Record<string, number>
): Promise<AIAnalysisResult> {
  const model = this.genAI.getGenerativeModel({
    model: this.modelName,
    generationConfig: {
      responseMimeType: "application/json",
      temperature: 0.3,
      maxOutputTokens: 2000,
    },
  });

  const prompt = buildAnalysisPrompt(tenderContent, weights);

  try {
    const result = await withRetry(
      () => withTimeout(model.generateContent(prompt), 30_000),
      { maxRetries: 1, baseDelayMs: 2000 }
    );

    const text = result.response.text();
    const json = extractJSON(text);
    const parsed = analysisResponseSchema.parse(JSON.parse(json));
    return parsed;
  } catch (err) {
    throw classifyError(err);
  }
}
```

Same pattern for `extractFromPDF` and for `GroqProvider.analyze`.

---

## Pattern 3: Applying Retry to GroqProvider

```typescript
// In groq.ts — same pattern
import { withRetry, withTimeout, classifyError } from "./retry";

async analyze(
  tenderContent: string,
  weights: Record<string, number>
): Promise<AIAnalysisResult> {
  const prompt = buildAnalysisPrompt(tenderContent, weights);

  try {
    const completion = await withRetry(
      () => withTimeout(
        this.client.chat.completions.create({
          model: this.modelName,
          messages: [
            {
              role: "system",
              content: "You are an expert Saudi government tender analyst. Respond with JSON only.",
            },
            { role: "user", content: prompt },
          ],
          temperature: 0.3,
          max_tokens: 2000,
          response_format: { type: "json_object" },
        }),
        30_000
      ),
      { maxRetries: 1, baseDelayMs: 2000 }
    );

    const text = completion.choices[0]?.message?.content ?? "";
    const json = extractJSON(text);
    const parsed = analysisResponseSchema.parse(JSON.parse(json));
    return parsed;
  } catch (err) {
    throw classifyError(err);
  }
}
```

---

## Pattern 4: Testing the AI Providers (Acceptance Test Script)

Create a simple test script or Server Action to verify the acceptance test criteria:

```typescript
// app/actions/test-ai.ts (temporary — for acceptance testing)
"use server";

import { getAIProvider } from "@/lib/ai/provider";
import type { AIAnalysisResult } from "@/lib/ai/provider";

const SAMPLE_TENDER = `
عنوان المنافسة: توريد أجهزة حاسب آلي لوزارة التعليم
الجهة: وزارة التعليم
رقم المنافسة: 1446-MOE-IT-001
الموعد النهائي: 2026-04-15
القيمة التقديرية: 2,500,000 ريال
الوصف: توريد وتركيب 500 جهاز حاسب مكتبي مع شاشات وملحقات.
المتطلبات:
- أجهزة حاسب مكتبي بمواصفات عالية
- شاشات 24 بوصة
- ضمان 3 سنوات
- خدمات التركيب والصيانة
`;

const DEFAULT_WEIGHTS = {
  relevance: 30,
  budgetFit: 25,
  timeline: 20,
  competition: 15,
  strategic: 10,
};

export async function testAIProvider(): Promise<{
  provider: string;
  success: boolean;
  result?: AIAnalysisResult;
  error?: string;
  durationMs: number;
}> {
  const start = Date.now();
  const provider = getAIProvider();

  try {
    const result = await provider.analyze(SAMPLE_TENDER, DEFAULT_WEIGHTS);
    return {
      provider: provider.modelName,
      success: true,
      result,
      durationMs: Date.now() - start,
    };
  } catch (err) {
    return {
      provider: provider.modelName,
      success: false,
      error: err instanceof Error ? err.message : String(err),
      durationMs: Date.now() - start,
    };
  }
}
```

This lets you run the acceptance test from a simple UI button or via `testAIProvider()` call.

---

## Pattern 5: Mock Provider Verification

The `MockProvider` must return data that passes the Zod schemas. Verify this:

```typescript
// Quick verification (run in test or dev console)
import { analysisResponseSchema } from "@/lib/ai/parser";
import { MockProvider } from "@/lib/ai/mock-provider";

const mock = new MockProvider();
const result = await mock.analyze("test", { relevance: 30 });

// This MUST NOT throw
analysisResponseSchema.parse(result);
```

If the mock data shape doesn't match the schema, the mock provider is useless for testing.

---

## Files to CREATE

| File | Purpose |
|------|---------|
| `src/lib/ai/retry.ts` | Retry, timeout, error classification utilities |

## Files to MODIFY (add retry/timeout)

| File | Changes |
|------|---------|
| `src/lib/ai/gemini.ts` | Wrap `analyze()` and `extractFromPDF()` with `withRetry` + `withTimeout` + `classifyError` |
| `src/lib/ai/groq.ts` | Wrap `analyze()` with `withRetry` + `withTimeout` + `classifyError` |
| `src/lib/ai/parser.ts` | Fix `zod/v4` import if needed (check installed version) |

## Files to VERIFY (do NOT modify unless broken)

| File | Verify |
|------|--------|
| `src/lib/ai/provider.ts` | `getAIProvider()` returns correct provider per env vars |
| `src/lib/ai/mock-provider.ts` | Mock data passes `analysisResponseSchema` and `extractionResponseSchema` |
| `src/lib/ai/prompts.ts` | `buildAnalysisPrompt()` weight replacement works correctly |
| `src/stores/settings-store.ts` | Weight keys match `buildAnalysisPrompt()` expectations |
| `src/types/ai.ts` | `TenderAnalysis` and `ExtractionResult` are consistent with provider types |

## Files to OPTIONALLY CREATE (for acceptance testing)

| File | Purpose |
|------|---------|
| `src/app/actions/test-ai.ts` | Temporary Server Action to test AI provider end-to-end |

---

## Acceptance Test Checklist (from IMPLEMENTATION.md)

After implementation, verify:

- [ ] Can call Gemini API and get a response (set `GEMINI_API_KEY` in `.env.local`)
- [ ] Can call Groq API and get a response (set `GROQ_API_KEY` + `AI_PROVIDER=groq`)
- [ ] Switching `AI_PROVIDER` env var switches the provider
- [ ] Response parses into typed `AIAnalysisResult` (Zod validation passes)
- [ ] Invalid AI responses are caught and return error state (not crash)
- [ ] `MOCK_AI=true` returns valid mock data (Zod validation passes)
- [ ] Timeout fires after 30s (test with a slow prompt or mock delay)
- [ ] Retry fires once on 429/5xx (verify with logging)
- [ ] `pnpm build` passes
- [ ] `tsc --noEmit` passes

---

## Recommendation Field Mapping Reference (for Phase 2.2)

This is NOT Phase 2.1's job, but document it here so Phase 2.2 knows:

| AI Output (`provider.ts`) | DB Column (`evaluations.auto_recommendation`) | DB Column (`tenders.recommendation`) |
|----------------------------|-----------------------------------------------|--------------------------------------|
| `"pursue"` | `"proceed"` | `"proceed"` |
| `"review"` | `"review"` | `"review"` |
| `"skip"` | `"skip"` | `"skip"` |

Map in Phase 2.2's `analyzeTender` Server Action:

```typescript
const dbRecommendation = result.recommendation === "pursue" ? "proceed" : result.recommendation;
```

---

## Installed SDK Versions (verified)

| Package | Version | Notes |
|---------|---------|-------|
| `@google/generative-ai` | 0.24.1 | `responseMimeType: "application/json"` supported |
| `groq-sdk` | 0.37.0 | `response_format: { type: "json_object" }` supported |
| `zod` | Check with `pnpm ls zod` | If 3.x, fix `parser.ts` import |

---

## Performance Notes

- **Gemini**: `gemini-2.5-flash` typically responds in 2-5s for analysis, 5-15s for PDF extraction
- **Groq**: `llama-3.3-70b-versatile` typically responds in 1-3s for analysis (no PDF support)
- **Mock**: Instant (0ms) — always use for UI development
- **Timeout**: 30s covers even slow Gemini responses; don't set lower
- **Retry**: 1 retry with 2s backoff is enough for transient 429s; more retries waste demo time

---

## Next Phase Dependencies

Phase 2.2 (Analysis Server Action & UI) will:
- Create `analyzeTender` Server Action that calls `getAIProvider().analyze()`
- Save results to `evaluations` table (map `"pursue"` → `"proceed"`)
- Update `tenders.evaluation_score` and `tenders.recommendation`
- Build ScoreGauge, ScoreBreakdown, EvidenceQuotes, RecommendationCard components
- Build the Tender Detail page (`tenders/[id]/page.tsx`)

Ensure Phase 2.1 delivers working `analyze()` calls with error handling before Phase 2.2 starts.
